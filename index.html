<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>numerical music explorer</title>
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #ffffff;
            color: #000000;
            font-family: 'Ubuntu Mono', monospace;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            box-sizing: border-box;
        }

        .container {
            width: 100%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .controls {
            display: flex;
            gap: 10px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            align-items: center;
            flex-wrap: wrap;
            background: #f9f9f9;
        }

        button {
            background: #eee;
            color: #000;
            border: 1px solid #999;
            padding: 6px 12px;
            font-family: inherit;
            cursor: pointer;
            border-radius: 3px;
        }

        button:hover { background: #ddd; }
        button.active { background: #4caf50; color: white; border-color: #4caf50; }
        
		button#pauseBtn.active { 
			background: #ffa000; 
			color: white; 
			border-color: #e68a00; 
		}

		button#stopBtn.active { 
			background: #d32f2f; 
			color: white; 
			border-color: #b71c1c; 
		}
		
        input[type="number"], input[type="text"] {
            background: #fff;
            border: 1px solid #ccc;
            color: #000;
            padding: 6px;
            font-family: inherit;
            border-radius: 3px;
        }

        .track-wrapper {
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .track-label {
            font-size: 0.9rem;
            font-weight: bold;
            color: #333;
        }

        .editor-container {
            position: relative;
            width: 100%;
            border: 1px solid #333;
            background: #fff;
        }

        .editor-backdrop, .editor-textarea {
            width: 100%;
            min-height: 60px;
            margin: 0;
            padding: 8px;
            box-sizing: border-box;
            font-family: 'Ubuntu Mono', monospace;
            font-size: 16px;
            line-height: 1.2;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow: auto;
        }

        .editor-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            color: transparent;
            pointer-events: none;
            background: transparent;
            border: none;
            scrollbar-width: none; 
        }
        .editor-backdrop::-webkit-scrollbar { display: none; }

        .editor-textarea {
            position: relative;
            z-index: 2;
            background: transparent;
            color: black;
            resize: vertical;
            outline: none;
            display: block;
            border: none;
        }

        .editor-textarea:focus {
            box-shadow: inset 0 0 0 1px #4caf50;
        }

        mark {
            background-color: #a5d6a7;
            color: transparent;
            border-radius: 2px;
        }

        .status-bar {
            font-size: 0.85em;
            color: #666;
            height: 1.5em;
            font-weight: bold;
            transition: color 0.2s;
        }
        
        .midi-group {
            margin-left: auto;
            display: flex;
            gap: 5px;
        }
		
		.notes-wrapper {
    width: 100%;
    margin-top: -10px;
}

	#notesToggle {
		background: none;
		border: none;
		padding: 0;
		font-family: inherit;
		font-size: 0.85em;
		color: #666;
		cursor: pointer;
		text-align: left;
	}

	#notesToggle:hover {
		color: #000;
	}

	.notes-content {
		margin-top: 6px;
	}

	.notes-content textarea {
		width: 100%;
		min-height: 80px;
		resize: vertical;
		background: #fff;
		color: #000;
		border: 1px solid #ccc;
		padding: 8px;
		font-family: 'Ubuntu Mono', monospace;
		font-size: 14px;
		box-sizing: border-box;
	}

	.hidden {
		display: none;
	}
	
	.syntax-help-wrapper {
    width: 100%;
    margin-top: -10px;
	margin-bottom: 40px;
}

	#syntaxHelpToggle {
		background: none;
		border: none;
		padding: 0;
		font-family: inherit;
		font-size: 0.85em;
		color: #666;
		cursor: pointer;
		text-align: left;
	}

	#syntaxHelpToggle:hover {
		color: #000;
	}

	.syntax-help-content {
		margin-top: 6px;
	}

	.syntax-help-text {
		font-size: 0.85em;
		color: #333;
		background: #f9f9f9;
		border: 1px solid #ccc;
		padding: 8px;
		font-family: 'Ubuntu Mono', monospace;
		line-height: 0.5;
		white-space: pre-wrap;
	}

	.hidden {
		display: none;
	}
	
    </style>
</head>
<body>

    <div class="container">
        <div class="controls">
            <button id="playBtn" title="Ctrl+Enter">play</button>
            <button id="pauseBtn">pause</button>
            <button id="stopBtn">stop</button>
            <button id="repeatBtn">repeat: off</button>
            <label>bpm: <input type="number" id="bpm" value="120" style="width: 50px;"></label>
            
            <div class="midi-group">
                <input type="text" id="filename" value="" placeholder="filename">
                <button id="exportBtn">export midi</button>
            </div>
        </div>

        <div class="track-wrapper">
            <div class="track-label">1=C5</div>
            <div class="editor-container">
                <div class="editor-backdrop" id="backdrop1"></div>
                <textarea class="editor-textarea" id="track1" spellcheck="false" onscroll="syncScroll('1')"></textarea>
            </div>
        </div>

        <div class="track-wrapper">
            <div class="track-label">1=C4</div>
            <div class="editor-container">
                <div class="editor-backdrop" id="backdrop2"></div>
                <textarea class="editor-textarea" id="track2" spellcheck="false" onscroll="syncScroll('2')"></textarea>
            </div>
        </div>

        <div class="track-wrapper">
            <div class="track-label">1=C3</div>
            <div class="editor-container">
                <div class="editor-backdrop" id="backdrop3"></div>
                <textarea class="editor-textarea" id="track3" spellcheck="false" onscroll="syncScroll('3')"></textarea>
            </div>
        </div>

        <div class="status-bar" id="status"></div>
		
		<div class="notes-wrapper">
			<button id="notesToggle">notepad▾</button>
			<div id="notesContent" class="notes-content hidden">
				<textarea id="notes" placeholder="blah blah blah blah..." spellcheck="false"></textarea>
			</div>
		</div>
		
		<div class="syntax-help-wrapper">
			<button id="syntaxHelpToggle">syntax-help ▾</button>
			<div id="syntaxHelpContent" class="syntax-help-content hidden">
				<div class="syntax-help-text">
recognized keys (k): <br>
  <em>default = C</em><br>
  C C# D Eb E F F# G Ab A Bb B <br>
<br>
recognized modes (m): <br>
  <em>default = 1 AKA Major</em><br>
  1 2 3 4 5 6 7 <br>
<br>
recognized notes (n): <br>
  1 2 3 4 5 6 7 8 9 <br>
  <em>octave higher relative to 1: 8 = 1, 9 = 2</em><br>
  0 = rest <br>
<br>
Recognized divisions (d): <br>
  3 = triplets<br>
  5 = quintuplets<br>
  7 = septuplets<br>
<br>
recognized symbols and functions: <br>
<br>
~<br>
  extends the length of a beat by an eighth note<br>
<br>
*()<br>
  modifier symbol<br>
<br>
[]<br>
  denotes a chord - play contents simultaneously at same beat<br>
<br>
m*()<br>
  diatonic transpose AKA change parallel mode <br>
<br>
k*()<br>
  chromatic transpose AKA change key<br>
<br>
km*()<br>
  transposing with both key and mode parameters:<br>
<br>
r*() <br>
  repeat once <br>
<br>
i*() <br>
  play in reverse AKA backwards<br>
<br>
()/d<br>
  set irregular divisions <br>
				</div>
			</div>
		</div>

    </div>

<script>
const NOTES = ['C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B'];
const MAJOR_SCALE_INTERVALS = [0, 2, 4, 5, 7, 9, 11]; 
const BASE_MIDI = { top: 72, mid: 60, bot: 48 };

function updateStatus(msg, color = "#666") {
    const el = document.getElementById('status');
    el.innerText = msg;
    el.style.color = color;
}

function syncScroll(id) {
    const ta = document.getElementById('track' + id);
    const bd = document.getElementById('backdrop' + id);
    bd.scrollTop = ta.scrollTop;
    bd.scrollLeft = ta.scrollLeft;
}

const resizeObserver = new ResizeObserver(entries => {
    for (let entry of entries) {
        const id = entry.target.id.replace('track', '');
        const bd = document.getElementById('backdrop' + id);
        bd.style.width = entry.contentRect.width + 16 + 'px';
        bd.style.height = entry.contentRect.height + 16 + 'px';
    }
});

['1','2','3'].forEach(id => resizeObserver.observe(document.getElementById('track'+id)));

class Parser {
    constructor(input, baseMidi, trackId) {
        this.input = input;
        this.pos = 0;
        this.baseMidi = baseMidi;
        this.trackId = trackId;
    }

    peek(count = 0) { return this.input[this.pos + count] || ''; }
    skipSpace() { while (/\s/.test(this.peek())) this.pos++; }
    consume(count = 1) {
        let s = '';
        for(let i=0; i<count; i++) { s += this.input[this.pos] || ''; this.pos++; }
        return s;
    }
    isDigit(char) { return /[0-9]/.test(char); }

    parse() {
        this.pos = 0;
        return this.parseGroup(0, 0);
    }

    parseGroup(kOff, mOff) {
        let events = [];
        this.skipSpace();
        while (this.pos < this.input.length) {
            if (this.peek() === ')' || this.peek() === ']') return events;
            let items = this.parseRecursiveItem(kOff, mOff);
            if (items.length > 0) events = events.concat(items);
            else { if (this.peek() === ')' || this.peek() === ']') return events; this.consume(); }
            this.skipSpace();
        }
        return events;
    }

    parseRecursiveItem(kOff, mOff) {
        this.skipSpace();
        if (this.pos >= this.input.length) return [];

        if (this.checkToken('r*')) {
            this.consume(2);
            let inner = this.parseRecursiveItem(kOff, mOff);
            return [...inner, ...JSON.parse(JSON.stringify(inner))];
        }

        if (this.checkToken('i*')) {
            this.consume(2);
            let inner = this.parseRecursiveItem(kOff, mOff);
            return inner.reverse();
        }

        let keyMod = this.checkKeyMod();
        if (keyMod) {
            this.consume(keyMod.length + 1);
            return this.parseRecursiveItem(NOTES.indexOf(keyMod), mOff);
        }

        let modeMod = this.checkModeMod();
        if (modeMod) {
            this.consume(modeMod.length);
            return this.parseRecursiveItem(kOff, mOff + (parseInt(modeMod.value) - 1));
        }

        let content = this.parseAtom(kOff, mOff);

        this.skipSpace();
        if (this.peek() === '/') {
            this.consume();
            let divStr = '';
            while(this.isDigit(this.peek())) divStr += this.consume();
            let div = parseInt(divStr) || 1;
            content.forEach(e => e.duration = e.duration / div);
        }
        return content;
    }

    parseAtom(kOff, mOff) {
        const char = this.peek();
        if (char === '(') {
            this.consume();
            let group = this.parseGroup(kOff, mOff);
            this.skipSpace();
            if (this.peek() === ')') this.consume();
            return group;
        }
        if (char === '[') {
            const startIdx = this.pos;
            this.consume();
            let content = this.parseGroup(kOff, mOff);
            this.skipSpace();
            if (this.peek() === ']') this.consume();
            let midis = [];
            let maxD = 0;
            content.forEach(c => { midis.push(...c.notes); if(c.duration > maxD) maxD = c.duration; });
            let dur = maxD || 1;
            while(this.peek() === '~') { this.consume(); dur += 1; }
            return [{ notes: midis, duration: dur, range: [startIdx, this.pos], trackId: this.trackId }];
        }
        if (this.isDigit(char)) {
            const startIdx = this.pos;
            let n = parseInt(this.consume());
            let dur = 1;
            while(this.peek() === '~') { this.consume(); dur += 1; }
            let midi = this.calcMidi(n, kOff, mOff);
            return [{ notes: n === 0 ? [] : [midi], duration: dur, range: [startIdx, this.pos], trackId: this.trackId }];
        }
        return [];
    }

    checkToken(str) { return this.input.substr(this.pos, str.length) === str; }
    checkKeyMod() {
        const sorted = [...NOTES].sort((a,b) => b.length - a.length);
        for(let k of sorted) if (this.checkToken(k + '*')) return k;
        return null;
    }
    checkModeMod() {
        if (this.isDigit(this.peek()) && this.peek(1) === '*') return { value: this.peek(), length: 2 };
        if (this.isDigit(this.peek()) && this.peek(1) === '(') return { value: this.peek(), length: 1 };
        return null;
    }
    calcMidi(n, kOff, mOff) {
        let total = (n - 1) + mOff;
        let oct = Math.floor(total / 7);
        let deg = ((total % 7) + 7) % 7;
        return this.baseMidi + kOff + MAJOR_SCALE_INTERVALS[deg] + (oct * 12);
    }
}

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let schedulerID = null, visualID = null;
let nextNoteTime = 0.0, currentEventIndex = 0;
let globalEvents = [], isPlaying = false, isRepeat = false;

function compile() {
    try {
        const bpm = parseInt(document.getElementById('bpm').value) || 120;
        const beatDur = 30 / bpm; 
        const tracks = ['1','2','3'].map(id => new Parser(document.getElementById('track'+id).value, Object.values(BASE_MIDI)[id-1], id).parse());
        let timeline = [];
        tracks.forEach(tEvs => {
            let cur = 0;
            tEvs.forEach(e => {
                timeline.push({ ...e, absTimeSec: cur * beatDur, durSec: e.duration * beatDur, time: cur });
                cur += e.duration;
            });
        });
        updateStatus("ready");
        return timeline.sort((a, b) => a.absTimeSec - b.absTimeSec);
    } catch(e) {
        updateStatus("syntax error", "#d32f2f");
        return [];
    }
}

// ELECTRIC GUITAR CLEAN SYNTH
function playNote(midi, time, dur) {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();
    
    // Square wave gives that harmonically rich "clean electric" base
    osc.type = 'square';
    osc.frequency.value = 440 * Math.pow(2, (midi - 69) / 12);
    
    // Filter to warm up the tone
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(1500, time);
    filter.frequency.exponentialRampToValueAtTime(800, time + dur);

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(audioCtx.destination);
    
    // Guitar Pluck Envelope
    gain.gain.setValueAtTime(0, time);
    gain.gain.linearRampToValueAtTime(0.08, time + 0.005); // Sharp Attack
    gain.gain.exponentialRampToValueAtTime(0.001, time + dur + 0.5); // Long Decay
    
    osc.start(time);
    osc.stop(time + dur + 0.6);
}

function clearButtonStates() {
    document.getElementById('playBtn').classList.remove('active');
    document.getElementById('pauseBtn').classList.remove('active');
    document.getElementById('stopBtn').classList.remove('active');
}

function startPlayback() {
    if (isPlaying) stopPlayback();
    if (audioCtx.state === 'suspended') audioCtx.resume();
    globalEvents = compile();
    if (globalEvents.length === 0) return;
    
    isPlaying = true; 
    currentEventIndex = 0;
    nextNoteTime = audioCtx.currentTime + 0.1;
	
	clearButtonStates();
    document.getElementById('playBtn').classList.add('active');
    updateStatus("playing...", "#4caf50");
    
    schedulerID = requestAnimationFrame(scheduler);
    visualID = requestAnimationFrame(visualizer);
}

function scheduler() {
    if (!isPlaying) return;
    while (currentEventIndex < globalEvents.length && globalEvents[currentEventIndex].absTimeSec + nextNoteTime < audioCtx.currentTime + 0.1) {
        let ev = globalEvents[currentEventIndex];
        ev.notes.forEach(n => playNote(n, nextNoteTime + ev.absTimeSec, ev.durSec));
        currentEventIndex++;
    }
    if (currentEventIndex >= globalEvents.length) {
        let last = globalEvents[globalEvents.length-1];
        let end = nextNoteTime + last.absTimeSec + last.durSec;
        if (audioCtx.currentTime > end) {
            if (isRepeat) { currentEventIndex = 0; nextNoteTime = audioCtx.currentTime + 0.1; }
            else stopPlayback();
        }
    }
    schedulerID = requestAnimationFrame(scheduler);
}

function visualizer() {
    if (!isPlaying) return;
    const now = audioCtx.currentTime - nextNoteTime;
    const active = { '1': new Set(), '2': new Set(), '3': new Set() };
    globalEvents.forEach(ev => {
        if (now >= ev.absTimeSec && now < ev.absTimeSec + ev.durSec) {
            for(let i=ev.range[0]; i<ev.range[1]; i++) active[ev.trackId].add(i);
        }
    });
    ['1','2','3'].forEach(id => {
        const text = document.getElementById('track'+id).value;
        let html = '';
        for(let i=0; i<text.length; i++) html += active[id].has(i) ? `<mark>${text[i]}</mark>` : text[i];
        document.getElementById('backdrop'+id).innerHTML = html;
    });
    visualID = requestAnimationFrame(visualizer);
}

function stopPlayback() {
    isPlaying = false;
    cancelAnimationFrame(schedulerID); cancelAnimationFrame(visualID);
    document.getElementById('playBtn').classList.remove('active');
	clearButtonStates();
    document.getElementById('stopBtn').classList.add('active');
    updateStatus("stopped.", "#d32f2f");    
	['1','2','3'].forEach(id => document.getElementById('backdrop'+id).innerHTML = document.getElementById('track'+id).value);
}

// --- IMPROVED LIVE PREVIEW LOGIC ---
function livePreview(trackId, textarea, inputType) {
    // 1. Ignore backspaces/deletions
    if (inputType === 'deleteContentBackward' || inputType === 'deleteContentForward') return;

    const pos = textarea.selectionStart;
    const text = textarea.value;
    const char = text[pos - 1];

    // 2. Only trigger if the last typed char is a note (1-9)
    if (/[1-9]/.test(char)) {
        if (audioCtx.state === 'suspended') audioCtx.resume();

        const baseMidi = Object.values(BASE_MIDI)[parseInt(trackId) - 1];
        const textBefore = text.substring(0, pos);
        
        // 3. Robust Lookback for Modifiers
        let kOff = 0;
        let mOff = 0;

        // Find the nearest Key (e.g., "G*", "Eb*")
        const keyRegex = /([A-G][b#]?)\*/g;
        let keyMatch;
        while ((keyMatch = keyRegex.exec(textBefore)) !== null) {
            kOff = NOTES.indexOf(keyMatch[1]);
        }

        // Find the nearest Mode (e.g., "2*", "3(")
        const modeRegex = /([1-7])[\*\(]/g;
        let modeMatch;
        while ((modeMatch = modeRegex.exec(textBefore)) !== null) {
            mOff = parseInt(modeMatch[1]) - 1;
        }

        // 4. Calculate and Play
        const tempParser = new Parser('', baseMidi, trackId);
        const noteVal = parseInt(char);
        const midi = tempParser.calcMidi(noteVal, kOff, mOff);
        
        playNote(midi, audioCtx.currentTime, 0.3);
    }
}

['1', '2', '3'].forEach(id => {
    const el = document.getElementById('track' + id);
    
    el.addEventListener('input', (e) => {
        const now = new Date();
        const hours = String(now.getHours()).padStart(2, '0');
        const mins = String(now.getMinutes()).padStart(2, '0');
        const timeString = `${hours}:${mins}`;

        document.getElementById('backdrop' + id).innerHTML = e.target.value;
        
        updateStatus(`last modified: ${timeString}`);
        
        livePreview(id, e.target, e.inputType);
    });

    el.addEventListener('scroll', () => syncScroll(id));
});

document.getElementById('pauseBtn').onclick = () => { 
    isPlaying = false; 
    clearButtonStates();
    document.getElementById('pauseBtn').classList.add('active');
    updateStatus("paused—", "#ffa000"); 
};

['1','2','3'].forEach(id => {
    document.getElementById('track'+id).addEventListener('input', e => document.getElementById('backdrop'+id).innerHTML = e.target.value);
});
document.getElementById('playBtn').onclick = startPlayback;
document.getElementById('stopBtn').onclick = stopPlayback;
document.getElementById('repeatBtn').onclick = e => {
    isRepeat = !isRepeat;
    e.target.innerText = isRepeat ? "repeat: on" : "repeat: off";
    e.target.style.color = isRepeat ? "#4caf50" : "";
};

const notesToggle = document.getElementById('notesToggle');
const notesContent = document.getElementById('notesContent');

notesToggle.addEventListener('click', () => {
    const isHidden = notesContent.classList.toggle('hidden');
    notesToggle.textContent = isHidden ? 'notes ▾' : 'notes ▴';
});

const syntaxToggle = document.getElementById('syntaxHelpToggle');
const syntaxContent = document.getElementById('syntaxHelpContent');

syntaxToggle.addEventListener('click', () => {
    const hidden = syntaxContent.classList.toggle('hidden');
    syntaxToggle.textContent = hidden ? 'syntax-help ▾' : 'syntax-help ▴';
});

</script>
</body>
</html>
